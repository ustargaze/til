# Dijkstra 算法

> 来源：https://oi-wiki.org/graph/shortest-path/#dijkstra-%E7%AE%97%E6%B3%95

求解非负权图上单源最短路径的算法。

## 过程

将节点分成两个集合：已确定最短路径长度的点集（记为 S 集合）和未确定最短路长度的点集（记为 T 集合）。一开始所有的点都属于 T 集合。

初始化 dis(s) = 0，其他点的 dis 均为 +∞。

重复以下操作：

1. 从 T 中，选取一个最短路长度最小的节点，移到 S 中。
2. 对刚加入 S 集合的节点的所有出边执行松弛操作。

知道 T 为空，算法结束。

## 时间复杂度

- 暴力：不实用任何数据结构进行维护，每次操作 2 执行完后，直接在 T 集合中暴力寻找最短路长度最小的节点。操作 2 总时间复杂度为 $O(m)$，操作 1 总时间复杂度为 $O(n^2)$，全过程的时间复杂度为 $O(m+n^2)=O(n^2)$。
- 优先队列：使用优先队列，如果同一个点的最短路被更新多次，因为先前更新时插入的元素不能被删除，也不能被修改，只能修改优先队列中，故优先队列内的元素个数是$O(m)$ 的，时间复杂度为 $O(m \log m)$

- ......

在稀疏图中 $m=O(n)$，而在稠密图中 $m=O(n^2)$，这时候使用暴力做法实现更优。



## 实践

- [1976. 到达目的地的方案数](https://leetcode.cn/problems/number-of-ways-to-arrive-at-destination/)


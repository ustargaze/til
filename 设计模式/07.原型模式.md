# 原型模式

## 概述

在面向对象系统中可以通过复制一个原型对象得到多个与原型对象一模一样的心对象，这就是原型模式的动机。

**原型模式**：使用原型实例指定待创建对象的类型，并且通过复制这个原型来创建新的对象。

> **Prototype Pattern**: Specify the kinds of objects to create using a prototypical instance, and create new objects by copying this prototype.

原型模式是一种**对象创建型模式**，工作原理很简单：将一个原型对象传给要发动创建的对象（即客户端对象），这个要发送创建的对戏那个通过请求原型对象复制自己来实现创建过程。由于在软件系统中经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在软件开发中具有较高的使用频率。原型模式是一种“另类”的创建型模式，创建新对象（也称为克隆对象）的工厂就是原型类自身，工厂方法由负责复制原型对象的克隆方法来实现。

需要注意的是通过克隆方法所创建对象是全新的对象，在内存中拥有新的地址。

## 结构与实现

### 结构

原型模式的结构如下图所示。

![protoype-pattern.svg](./assets/protoype-pattern.svg)

原型模式包含 3 个角色：

1. **Prototype（抽象原型类）**：声明克隆方法的接口，是所有具体原型类的公共父类，它可以是抽象类也可以是接口，甚至还可以是具体实现类。
2. **ConcretePrototype（具体原型类）**：实现了在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。
3. **Client（客户类）**：在客户类中，让一个原型对象克隆自身从而创建一个新的对象，只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。

### 浅克隆与深克隆

1. **浅克隆（Shallow Clone）**

   在浅克隆中，当原型对象被复制时，只复制了它本身和其中包含的值类型的成员变量，而引用类型的成员变量并没有复制。

2. **深克隆（Deep Clone）**

   在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将被复制。
   
   深克隆的一种简单实现方式：将原对象序列化然后再反序列化得到克隆对象。

### 实现

[原型模式实现示例](./examples/designpattern/prototype)

**Java 中的 clone() 方法和 Cloneable 接口**

Object 类提供了一个 clone() 方法，可以将一个 Java 对象复制一份。因此在 Java 中可以直接使用 Object 提供的 clone() 方法来实现对象的浅克隆。如果需要使用 clone() 方法进行克隆，必须实现一个标识接口 Cloneable，表示这个接口支持被复制。如果没有实现接口但是调用了 clone() 方法，会抛出一个 CloneNotSupportedException 异常。

Java 中的 clone() 方法满足以下几点：

1. x.clone() != x 为 true，即克隆对象与原型对象不是同一个。
2. x.clone().getClass() == x.getClass() 为 true，即克隆对象与原型对象的类型一样。
3. x.clone().equals(x) 应当为 true。

> 2 和 3 为非绝对性要求。

## 优/缺点与适用环境

### 优点

1. 当创建新的对象实例比较复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。
2. 扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统没有任何影响。
3. 原型模式提供了简化的建造结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。
4. 可以使用深克隆的方法保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候（例如恢复到某一历史状态），可辅助实现撤销操作。

### 缺点

1. 需要为每个一类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时需要修改源代码，违背了开闭原则。
2. 在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能比较麻烦。

### 适用环境

1. 创建新对象成本较大（例如初始化需要占用较长的时间、占用太多的 CPU 资源或网络资源），新对象可以通过复制已有对象来获得，如果是相似对象，则可以对其成员变量稍作修改。
2. 系统要保存对象的状态，而对象的状态变化很小。
3. 需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。
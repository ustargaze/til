# 观察者模式

## 概述

在软件系统中，一个对象的状态或行为的变化将导致其他对象的状态或行为也发生改变，它们之间将产生联动，正所谓“触一而牵百发”。为了更好地描述对象之间存在的这种一对多（包括一对一）的联动，观察者模式应运而生，它定义了对象之间一种一对多的依赖关系，让一个对象的改变能够影响其他对象。

观察者模式是使用频率较高的设计模式之一，它用于建立一种对象与对象之间的依赖关系，一个对象法身改变时将自动通知其他对象，其他对象将相应作出反应。在观察者模式中发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间可以没有任何相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展。

**观察者模式**：定义对象之间的一种一对多的依赖关系，使得每当一个对象状态发生改变时其相关依赖对象皆得到通知并被自动更新。

> **Observer Pattern**: Define a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.

观察者模式的别名有发布-订阅（Publish-Subscribe）模式、模型-视图（Model-View）模式、源-监听器（Source-Listener）模式、从属者（Dependents）模式。观察者模式是一种对象行为型模式。

## 结构与实现

### 结构

观察者模式的结构如下图。

![observer-pattern.svg](./assets/observer-pattern.svg)

观察者模式包含 4 个角色：

1. **Subject（目标）**：目标又称为主题，它是指被观察到对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者模式，同时它定义了通知方法 notify()。目标类可以是接口，也可以是抽象类或具体类。
2. **ConcreteSubject（具体目标）**：具体目标是目标类的子类，它通常包含有经常发生改变的数据，当它的状态发生改变时将向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有）。如果无需扩展目标类，则具体目标类可以省略。
3. **Observer（观察者）**：观察者将对观察目标的改变作出发硬，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。
4. **ConcreteObserver（具体观察者）**：在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update() 方法。通常在实现时可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。

### 实现

[观察者模式实现示例](./examples/designpattern/observer)

## JDK 对观察者模式的支持

在 JDK 的 java.util 包中提供了 Observable 类以及 Observer 接口，它们构成了 JDK 对观察者模式的支持。

![jdk-observer-pattern.svg](./assets/jdk-observer-pattern.svg)

## 观察者模式与 Java 事件处理

JDK 1.0 及更早的版本的时间模型基于职责链模式，但是这种模型不适用于复杂的系统，因此在 JDK 1.1 及以后的各个版本中事件处理模型采用基于观察者模式的委派事件模型（Delegation Event Model，DEM），即一个Java 组件所引发的事件并不由引发事件的对象自己来负责处理，而是委派给独立的事件处理对象负责。

在 DEM 模型中目标角色（如界面组件）负责发布事件，而观察者角色（事件处理者）可以向目标订阅它所感兴趣的事件。当一个具体目标产生一个事件时它将通知所有订阅者。事件的发布者称为事件源（Event Source），而订阅者称为事件监听器（Event Listener），在这个过程中还可以通过事件对象（Event Object）来传递与事件相关的信息，可以在事件监听者的实现类中实现事件处理，因此事件监听对象又可以称为事件处理对象。事件源对象、事件监听对象（事件处理对象）和事件对象构成了 Java 事件处理模型的三要素。事件源对象充当观察目标，而事件监听对象充当观察者。

## 观察者模式与 MVC

流行的 MVC（Model-View-Controller）架构中也应用了观察者模式，MVC 是一种架构模式，它包含 3 个角色，即模型（Model）、视图（View）、控制器（Controller）。其中，模型对应于观察者模式中的观察目标，而视图对应与观察者，控制器可充当两者之间的中介者。当模型层的数据发生改变时视图层将自动改变其显示内容。

## 优/缺点与适用环境

### 优点

1. 可以实现表示层和数据逻辑层的分离，定义了稳定的消息更新传递机制，并抽象了更新接口，使得可以有各种各样不同的表示层充当具体观察者角色。
2. 在观察目标和观察者之间建立一个抽象的耦合。观察目标只需要维持一个抽象观察者的集合，无需了解其具体观察者。由于观察目标和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次。
3. 支持广播通信，观察目标会向所有已注册的观察者对象发送通知，简化了一对多系统设计的难度。
4. 符合开闭原则，增加新的具体观察者无需修改原有系统代码，在具体观察者与观察目标之间不存在关联关系的情况下增加新的观察目标也很方便。

### 缺点

1. 如果一个观察目标对象有很多直接或间接观察者，将所有的观察者都通知到会花费很多时间。
2. 如果在观察者和观察目标之间存在循环依赖，观察目标会出发它们之间进行循环调用，可能导致系统崩溃。
3. 观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。

### 适用环境

1. 一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两个方面封装在独立的对象中使它们可以各自独立地改变和复用。
2. 一个对象的改变将导致一个或多个其他对象也发生改变，而并不知道具体有多少对象将发生改变，也不知道这些对象是谁。
3. 需要在系统中创建一个触发链，A 对象的行为将影响 B 对象，B 对象的行为将影响 C 对象……，可以使用观察者模式创建一种链式触发机制。

# 解释器模式

## 概述

解释器模式是一种使用频率相对较低且学习难度相对较大的设计模式，它用于描述如何使用面向对象语言构成一个简单的语言解释器。在某些情况下，为了更好地描述某些特定类型的问题可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应为该语言中的句子，此时可以使用解释器模式来设计这种新的语言。对解释器模式的学习能够加深对面相对象思想的理解，并且理解编程语言中文法规则的解释过程。

**解释器模式**：给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。

> **Interpreter Pattern**: Given a language, define a representation for its grammer along with an interprerter that uses the representation to interprer sentences in the language.

在解释器模式的定义中所指的“语言”是使用规定格式和语法的代码，解释器模式是一种类行为型模式。

## 文法规则和抽象语法树

例如一个加法/减法解释器，只需要提供一个加法/减法表达式，它就能计算出表达式结果。

在加法/减法解释器中，每输入一个表达式（例如“1+2+3-4+1”）都包含了 3 个语言单位，可以使用以下文法规则来定义：

```
expression ::= value | operation
operation ::= expression '+' expression | expression '-' expression
value ::= an interger // 一个整数值
```

文法规则中包含 3 条语句，第一条表示表达式的组成方式，其中 value 和 operation 是后面两个语言单位的定义，每一条语句所定义的字符串（如 operation 和 value）称为语言构造成分或语言单位，符号 `::=` 是“定义为”的意思，其左边的语言单位通过右边来进行说明和定义，语言单位对应终结符表达式和非终结符表达式。（operation 为非终结符表达式，组成元素仍为表达式，可以进一步分解，value 为终结符表达式，组成元素为最基本的语言单位，不能再进行分解。）

出了使用文法规则来定义一个语言外，在解释器模式中还可以通过一种称为抽象语法树（Abstract Syntax Tree，AST）的图形方式来直观地表示语言的构成，每一棵抽象语法树对应一个语言实例。表达式“1+2+3-4+1”可通过如下抽象语法树来表示。

![interpreter-pattern-ast.svg](./assets/interpreter-pattern-ast.svg)

## 结构与实现

### 结构

解释器模式的结构如下。

![interpreter-pattern.svg](./assets/interpreter-pattern.svg)

解释器模式包含 4 个角色：

1. **AbstractExpression（抽象表达式）**：在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。
2. **TraminalExpression（终结符表达式）**：终结符表达式是抽象表达式的子类，它实现了与文法的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式，它们的实例可以通过非终结符表达式组成较为复杂的句子。
3. **NonterminalExpression（非终结符表达式）**：非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此解释操作一般通过递归的方式完成。
4. **Context（环境类）**：环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它存储了需要解释的语句。

### 实现

[解释器模式实现示例](./examples/designpattern/interpreter)

## 优/缺点与适用环境

### 优点

1. 易于改变和扩展文法。由于在解释器模式中使用类表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。
2. 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言，
3. 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。
4. 增加新的解释表达式较为方便。如果用户需要增加新的解释器表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合开闭原则。

### 缺点

1. 对于复杂文法难以维护。在解释器模式中每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。
2. 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调用过程也比较麻烦。

### 适用环境

1. 可以将一个需要解释执行的语言中的句子表示为一棵抽象语法树。
2. 一些重复出现的问题可以用一种简单的语言进行表达。
3. 一个语言的文法较为简单，对于复杂的文法，解释器模式中的文法类层次结构将变得很庞大而无法管理，此时最好使用语法分析程序生成器。
4. 执行效率不是关键问题。高效的解释器通常不是通过直接解释抽象语法树来实现的，而是需要将它们转换成其他形式，使用解释器模式的执行效率并不高。

# 状态模式

## 概述

在软件系统中，有些对象具有多种状态，这些状态在某些情况下能够相互转换，而且对象在不同的状态下也将具有不同的行为。通常可以用复杂的条件判断语句（例如if……else……语句）来进行撞他判断和转换操作，这会导致代码的可维护性和灵活性下降，特别是在出现新的状态时代码的扩展性很差，客户端代码也需要进行相应的修改，违反了开闭原则，为了解决状态的转换问题，并使客户端代码与对象状态之间的耦合度降低，可以使用一种被称为状态模式的设计模式。

状态模式用于解决系统中复杂对象的状态转换以及不同状态下行为的封装问题。当系统中的某个对象存在多个状态，这些状态之间可以进行转换，而且对象在不同状态下行为不相同时可以使用状态模式。状态模式将一个对象的状态从该对象中分离出来，封装到专门的状态类中，使得对象状态可以灵活变化。对于客户端而言，无须关系对象状态的转换以及对象所处的当前状态，无论对于何种状态的对象，客户端都可以一致处理。

**状态模式**：允许一个对象在其内部状态改变时改变它的行为。对象看起来似乎修改了它的类。

> **State Pattern**: Allow an objects to alter its behavior when its internal state changes. The object will appear to change its class.

## 结构与实现

### 结构

状态模式的结构如下图。

![state-pattern.svg](./assets/state-pattern.svg)

状态模式包含 3 个角色：

1. **Context（环境类）**：环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去行为单独的状态类。在环境类中维护一个抽象状态类 State 的实例，这个实例定义了当前状态，在具体实现时它是一个 State 子类的对象。
2. **State（抽象状态类）**：它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现了这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。
3. **ConcreteState（具体状态类）**：它是抽象状态类的子类，每一个子类实现了一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类的行为有所不同。

### 实现

[状态模式实现示例](./examples/designpattern/state)

在实际使用时，Context 与 State 之间可能存在更加复杂的关系（不只是单向关联），State 与 Context 之间可能也存在依赖或者双向关联关系。

在状态模式的使用过程中，一个对象的状态之间还可以进行相互转换，通常有两种实现状态转换的方式。

1. 统一由环境类来复杂状态之间的转换，此时环境类还充当了状态管理器（State Manager）角色，在环境类的业务方法中通过对某些属性值的判断实现状态转换，还可以提供一个专门的方法用于实现属性判断和状态转换。
2. 由具体状态类来复杂状态之间的转换，可以在具体状态类的业务方法中判断环境类的某些属性，再根据情况为环境类设置新的状态对象，实现状态转换。同样，也可以提供一个专门的方法来复杂属性值的判断和状态转换。此时状态类与环境类之间将存在依赖或关联关系，因为状态类需要访问环境类中的属性值。

## 共享状态

在有些情况下，多个环境对象可能需要共享同一个状态，如果希望在系统中实现多个环境对象共享一个或多个状态对象，那么需要将这些状态对象定义为环境类的静态成员对象。

## 优/缺点与适用环境

### 优点

1. 状态模式封装了状态的转换规则，在状态模式中可以讲状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。
2. 状态模式将所有与某个状态有关的行为都放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。
3. 状态模式允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以避免使用庞大的条件语句将业务方法和状态转换代码交织在一起。
4. 状态模式可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。

### 缺点

1. 状态模式会增加系统中类和对象的个数，导致系统运行开销增大。
2. 状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。
3. 状态模式对开闭原则的支持不太好，增加新的状态类需要修改哪些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需要修改对应类的源代码。

### 适用环境

1. 对象的行为依赖于它的状态（例如某些属性值），状态的改变将导致行为的变化。
2. 在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现会导致代码可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。


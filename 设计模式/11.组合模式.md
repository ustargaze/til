# 组合模式

## 概述

树形结构在软件中随处可见，例如操作系统中的目录结构、应用软件中的菜单结构、办公系统中的公司组织结构等。

以 Windows 操作系统中的目录结构为例，包含问价和文件夹两类不同元素，其中文件夹中可以包含文件，还可以继续包含文件夹，但是文件中不能再包含文件或者文件夹。在此可以称文件夹为容器（Container），而不同类型的文件是其成员，又称为叶子（Leaf）。

对于所有与目录结构相类似的树形结构，当容器对象（例如文件夹）的某一个方法被调用时将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象，例如文件夹和文件）并调用执行，牵一而动百，其中使用了递归调用的机制对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上在大多数情况下客户端希望一致地处理它们，因为对于这些对象的区别对待会使程序非常复杂。

组合模式通过一种巧妙的设计方案使得用户可以一致性地处理整个树形结构或者树形结构的一部分，它描述了如何将容器对象和叶子对象进行递归组合，使得用户在使用时无须对它们进行区分，可以一致地对待容器对象和叶子对象，这就是组合模式的模式动机。

**组合模式**：组合多个对象形成树形结构以表示具有部分-整体关系的层次结构。组合模式让客户端可以统一对待单个对象和组合对象。

> **Composite Pattern**: Compose objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.

组合模式又称为“部分-整体”（Part-Whole）模式，属于对象结构型模式，它将对象组织到树形结构中，可以用来描述整体和部分的关系。

## 结构与实现

### 结构

组合模式的结构如下图。

![composite-pattern.svg](./assets/composite-pattern.svg)

组合模式包含 3 个角色：

1. **Component（抽象构件）**：它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
2. **Leaf（叶子构件）**：它在组合结构中表示叶子结点对象，叶子结点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过抛出异常、提示错误等方式进行处理。
3. **Composite（容器构件）**：它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子结点，也可以是容器节点，它提供了一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点中的业务方法。

### 实现

[组合模式实现示例](./examples/designpattern/composite)

## 透明组合模式与安全组合模式

组合模式根据抽象构件的定义形式又可以分为透明组合模式和安全组合模式。

1. **透明组合模式**

   透明模式结构图如下。

   ![transparent-composite-pattern.svg](./assets/transparent-composite-pattern.svg)

   在透明组合模式中，抽象构件 Component 中声明了所有用于管理成员对象的方法（add、remove、getChild），这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以一致地对待所有的对象。

   这样做的缺点是不够安全，因为叶子对象和容器对象在本质上是有区别的。叶子对象不可能有下一个层次的对象，即不可能包含成员对象，因此提供管理成员对象的方法是没有意义的，这在编译阶段不会出错，但是在运行阶段如果调用这些方法可能会出错（如果没有提供相应的错误处理代码）。

2. **安全组合模式**

   安全组合模式结构如下图。

   ![safe-composite-pattern.svg](./assets/safe-composite-pattern.svg)

   在安全组合模式中，抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 Composite 类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些方法，对于叶子对象，客户端不肯呢恶搞调用到这些方法。

   这样做的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。

## 优/缺点与适用环境

### 优点

1. 可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
2. 客户端可以一致地使用一个组合结构或其中单个对象，不必关系处理的是单个对象还是整个组合结构，简化了客户端代码。
3. 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合开闭原则。
4. 为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合可以形成复杂的树形结构，但对树形结构的控制却非常简单。

### 缺点

在增加新构件时很难对容器中的构件类型进行限制。有时候希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，在使用组合模式时不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。

### 适用环境

1. 在具有整体和部分的层次结构中希望通过一种方式忽略整体于部分的差异，客户端可以一致地对待它们。
2. 在一个使用面向对象语言开发的系统中需要处理一个树形结构。
3. 在一个系统中能够分理出叶子对象和容器对象，而且它们的类型不固定，需要增加一些心的类型。


# 外观模式

## 概述

去茶馆喝茶和自己泡茶的区别？自己泡茶需要繁杂的工序和材料准备，而去茶馆喝茶只需要和服务员沟通即可，过程非常简单也很省事。

在软件开发中有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于设计的类比较多，导致使用时代码较为复杂，此时特别需要一个类似服务员的角色，有它来负责和多个业务类进行交互，而客户类只需要与该类交互。外观模式通过引入一个新的外观类（Facade）来实现该功能，外观类充当了软件系统中的“服务员”，它为多个业务类的调用提供了一个统一的入口，简化了类与类之间的交互。在外观模式中，那些需要交互的业务类被称为子系统（Subsystem）。如果没有外观类，每个客户类需要和多个子系统进行复杂的交互，系统的耦合度将很大；而引入外观类之后，客户类只需要直接与外观类交互，客户类与子系统之间的复杂引用关系由外观类来实现，从而降低了系统的耦合度。

在外观模式中，一个子系统的外部与其内部的通信通过一个统一的外观类进行，外观类将客户类与子系统的内部复杂性分隔开，使得客户类只需要与外挂角色打交道，而不需要与子系统内部的很多对象打交道。

**外观模式**：为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。

> **Facade Pattern**: Provide a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.

外观模式又称为门面模式，它是一种对象结构型模式。外观模式是迪米特法则的一种具体实现，通过引入一个新的外观角色可以降低原有系统的复杂度，同时降低客户类与子系统的耦合度。

## 结构与实现

### 结构

外观模式结构如下图。

![facade-pattern.svg](./assets/facade-pattern.svg)

外观模式包含 2 个角色：

1. **Facade（外观角色）**：在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统，传递给相应的子系统对象处理。
2. **Subsystem（子系统角色）**：在软件系统汇总可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现了子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它吃醋里由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。

### 实现

[外观模式实现示例](./examples/designpatterns/facade)

## 抽象外观类

在标准的外观模式结构中，如果需要增加、删除或更换与外观类交互的子系统类，必须修改外观类或客户端的源代码，这将违背开闭原则，因此可以通过引入抽象外观类对系统进行改进，这在一定程度上可以解决这个问题。在引入抽象外观类之后，客户端可以针对抽象外观类进行编程，对于新的业务需求，不需要修改原有外观类，而对应增加一个新的具体外观类，由新的具体外观类来关联新的子系统对象，同时通过修改配置文件来达到不修改任何源代码并更换外观类的目的。

## 优/缺点与适用环境

外观模式并不给系统增加任何新功能，只是简化调用接口。

### 优点

1. 它对客户端屏蔽了子系统组件，减少了客户端所需要处理的对象数目，并使子系统使用起来更容易。通过引入外观模式，客户端代码将变得更简单，与之关联的对象也很少。
2. 它实现了子系统与客户端之间的松耦合，这使得子系统的变化并不会影响到调用它的客户端，只需要调整外观类即可。
3. 一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。

### 缺点

1. 不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活性。
2. 如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。

### 适用环境

1. 当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。
2. 客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。
3. 在层次化结构中可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。


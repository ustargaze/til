# 迭代器模式

## 概述

在软件开发中存在可以存储多个成员对象（元素）的类，这些类通常称为聚合类（Aggregate Classes），对应的对象称为聚合对象。为了更加方便地操作这些聚合对象，同时可以很灵活地为聚合对象增加不同的遍历方法，需要一个可以访问聚合对象中的元素但又不需要暴露它的内部结构的角色。通过迭代器模式可以为对象提供一个遥控器，通过引入迭代器客户端无须了解聚合对象的内部结构即可实现对聚合对象中成员的遍历，还可以根据需要很方便地增加新的遍历方式。

在软件系统中聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责：二后者既是可变化的，又是可分离的。因此可以将遍历数据的行为从聚合对象中分离出来，封装在迭代器对象中，有迭代器来提供便利聚合对象内部数据的行为，这将简化聚合对象的设计，更符合单一职责原则的要求。

**迭代器模式**：提供一种方法顺序访问一个聚合对象中的各个元素，而又不用暴露该对象的内部表示。

> **Iterator Pattern**: Provide a way to access the elements of an aggregate object sequentially without exposing its underlying representation.

迭代器模式又称为游标（Cursor）模式，它是一种对象行为型模式。

## 结构与实现

### 结构

迭代器模式的结构如下所示。

![iterator-pattern.svg](./assets/iterator-pattern.svg)

迭代器模式包含 4 个角色：

1. **Iterator（抽象迭代器）**：它定义了访问和便利元素的接口，声明 了用于便利数据元素的方法，例如用于获取第一个元素的 first() 方法、用于访问下一个元素的 next() 方法、用于判断是否还有下一个元素的 hasNext() 方法、用于获取当前元素的 currentItem() 方法等，在具体迭代器中将实现这些方法。
2. **ConcreteIterator（具体迭代器）**：它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中国呢所处的当前位置，在具体实现时游标通常是一个表示位置的非负整数。
3. **Aggregate（抽象聚合类）**：它用于存储和管理元素对象，声明了一个 createIterator() 方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。
4. **ConcreteAggregate（具体聚合类）**：它是抽象聚合类的子类，实现了在抽象聚合类中声明的 createIterator() 方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。

### 实现

[迭代器模式实现示例](./examples/designpattern/iterator)

## 使用内部类实现迭代器

具体迭代器类和具体聚合类之间存在双重关系，其中一个关系为关联关系，在具体迭代器中需要维持一个对具体聚合对象的引用，该关系的目的是访问存储在聚合对象中的数据，以让迭代器能够对这些数据进行遍历操作。

除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，还可以将迭代器类设计为聚合类的内部类，JDK 中的迭代器类就是通过这种方法来实现的。

无论哪种实现机制，客户端代码都是一样的，也就是说客户端无须关心具体迭代器对象的创建细节，只需要通过调用工厂方法 createIterator() 即可得到一个可用的迭代器对象。

## Java 内置迭代器

在 JDK 中定义了抽象迭代器接口 Iterator，代码如下：

```java
package java.util;

public interface Iterator<E> {
    boolean hasNext();
    E next();
    void remove();
}
```

hasNext() 用于判断聚合对象中是否还存在下一个元素，为了不抛出异常，在每次调用 next() 之前需要先调用 hasNext()，如果有可供访问的元素，则返回 true；next() 方法用于将游标移至下一个元素，通过它可以逐个访问聚合中的元素，它返回游标所越过的那个元素的引用；remove() 方法用于删除上次调用 next() 时所返回的元素。

> next() 方法与 remove() 方法的调用是相互关联的。如果在调用 remove() 之前没有对 next() 进行调用，将抛出 IllegalStateException 异常，因为没有任何可供删除的元素。

## 优/缺点与适用环境

### 优点

1. 迭代器模式支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，也可以自己定义迭代器的子类以支持新的遍历方式。
2. 迭代器模式简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历的方法，这样可以简化聚合类的设计。
3. 在迭代器模式中由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足开闭原则。

### 缺点

1. 由于迭代器模式将存储数据和遍历数据的职责分离，在增加新的聚合类时需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。
2. 抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展。在自定义迭代器时创建一个考虑全面的抽象迭代器并不是一件很容易的事情。

### 适用环境

1. 访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内容不数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。
2. 需要为一个聚合对象提供多种遍历方式。
3. 为遍历不同的聚合结构提供了一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。